{"version":3,"file":"userIntegrations.js","sourceRoot":"","sources":["../../src/utils/userIntegrations.ts"],"names":[],"mappings":";;AAcA;;;;;;;;GAQG;AACH,8DAA8D;AAC9D,SAAS,YAAY,CAAC,GAAwB,EAAE,OAAe,EAAE,KAAc;IAC7E,iDAAiD;IACjD,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;IAC/C,IAAI,KAAK,KAAK,IAAI,EAAE;QAClB,GAAG,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;KACtB;SAAM;QACL,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;KAC9C;AACH,CAAC;AAED;;;;;;;;;;;GAWG;AACH,SAAgB,cAAc,CAC5B,WAAwB,EACxB,gBAAkC,EAClC,OAAqB;IAArB,wBAAA,EAAA,YAAqB;IAErB,IAAI,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;QACnC,OAAO,qBAAqB,CAAC,WAAW,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;KACtE;SAAM;QACL,OAAO,wBAAwB,CAAC,WAAW,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;KACzE;AACH,CAAC;AAVD,wCAUC;AAED,SAAS,qBAAqB,CAC5B,WAAwB,EACxB,gBAA+B,EAC/B,OAAgB;IAEhB,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,4DAA4D;IAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAChD,IAAI,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI,EAAE;YACjD,YAAY,GAAG,IAAI,CAAC;SACrB;QAED,IAAM,EAAE,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,EAAE,EAAE;YACN,YAAY,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;SACzD;KACF;IAED,IAAI,YAAY,EAAE;QAChB,OAAO,gBAAgB,CAAC;KACzB;IACD,wBAAW,gBAAgB,GAAE,WAAW,GAAE;AAC5C,CAAC;AAED,SAAS,wBAAwB,CAC/B,WAAwB,EACxB,oBAA8C,EAC9C,OAAgB;IAEhB,IAAM,OAAO,GAA6B,UAAA,mBAAmB;QAC3D,IAAM,qBAAqB,GAAG,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;QACxE,OAAO,qBAAqB,CAAC,WAAW,EAAE,qBAAqB,EAAE,OAAO,CAAC,CAAC;IAC5E,CAAC,CAAC;IACF,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["import { Integration } from '@sentry/types';\r\n\r\nexport type UserFunctionIntegrations = (integrations: Integration[]) => Integration[];\r\nexport type UserIntegrations = Integration[] | UserFunctionIntegrations;\r\n\r\ntype Options = {\r\n  [integrationName: string]:\r\n    | {\r\n        keyPath: string;\r\n        value: unknown;\r\n      }\r\n    | undefined;\r\n};\r\n\r\n/**\r\n * Recursively traverses an object to update an existing nested key.\r\n * Note: The provided key path must include existing properties,\r\n * the function will not create objects while traversing.\r\n *\r\n * @param obj An object to update\r\n * @param value The value to update the nested key with\r\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction setNestedKey(obj: Record<string, any>, keyPath: string, value: unknown): void {\r\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\r\n  const match = keyPath.match(/([a-z]+)\\.(.*)/i);\r\n  if (match === null) {\r\n    obj[keyPath] = value;\r\n  } else {\r\n    setNestedKey(obj[match[1]], match[2], value);\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves the patched integrations with the provided integration.\r\n *\r\n * The integration must be present in the final user integrations, and they are compared\r\n * by integration name. If the user has defined one, there's nothing to patch; if not,\r\n * the provided integration is added.\r\n *\r\n * @param integration The integration to patch, if necessary.\r\n * @param userIntegrations Integrations defined by the user.\r\n * @param options options to update for a particular integration\r\n * @returns Final integrations, patched if necessary.\r\n */\r\nexport function addIntegration(\r\n  integration: Integration,\r\n  userIntegrations: UserIntegrations,\r\n  options: Options = {},\r\n): UserIntegrations {\r\n  if (Array.isArray(userIntegrations)) {\r\n    return addIntegrationToArray(integration, userIntegrations, options);\r\n  } else {\r\n    return addIntegrationToFunction(integration, userIntegrations, options);\r\n  }\r\n}\r\n\r\nfunction addIntegrationToArray(\r\n  integration: Integration,\r\n  userIntegrations: Integration[],\r\n  options: Options,\r\n): Integration[] {\r\n  let includesName = false;\r\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\r\n  for (let x = 0; x < userIntegrations.length; x++) {\r\n    if (userIntegrations[x].name === integration.name) {\r\n      includesName = true;\r\n    }\r\n\r\n    const op = options[userIntegrations[x].name];\r\n    if (op) {\r\n      setNestedKey(userIntegrations[x], op.keyPath, op.value);\r\n    }\r\n  }\r\n\r\n  if (includesName) {\r\n    return userIntegrations;\r\n  }\r\n  return [...userIntegrations, integration];\r\n}\r\n\r\nfunction addIntegrationToFunction(\r\n  integration: Integration,\r\n  userIntegrationsFunc: UserFunctionIntegrations,\r\n  options: Options,\r\n): UserFunctionIntegrations {\r\n  const wrapper: UserFunctionIntegrations = defaultIntegrations => {\r\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\r\n    return addIntegrationToArray(integration, userFinalIntegrations, options);\r\n  };\r\n  return wrapper;\r\n}\r\n"]}