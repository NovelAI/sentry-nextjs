{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/performance/client.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport { Primitive, Transaction, TransactionContext } from '@sentry/types';\r\nimport { fill, getGlobalObject, stripUrlQueryAndFragment } from '@sentry/utils';\r\nimport { default as Router } from 'next/router';\r\n\r\nconst global = getGlobalObject<Window>();\r\n\r\ntype StartTransactionCb = (context: TransactionContext) => Transaction | undefined;\r\n\r\nconst DEFAULT_TAGS = Object.freeze({\r\n  'routing.instrumentation': 'next-router',\r\n});\r\n\r\nlet activeTransaction: Transaction | undefined = undefined;\r\nlet prevTransactionName: string | undefined = undefined;\r\nlet startTransaction: StartTransactionCb | undefined = undefined;\r\n\r\n/**\r\n * Creates routing instrumention for Next Router. Only supported for\r\n * client side routing. Works for Next >= 10.\r\n *\r\n * Leverages the SingletonRouter from the `next/router` to\r\n * generate pageload/navigation transactions and parameterize\r\n * transaction names.\r\n */\r\nexport function nextRouterInstrumentation(\r\n  startTransactionCb: StartTransactionCb,\r\n  startTransactionOnPageLoad: boolean = true,\r\n  startTransactionOnLocationChange: boolean = true,\r\n): void {\r\n  startTransaction = startTransactionCb;\r\n  Router.ready(() => {\r\n    // We can only start the pageload transaction when we have access to the parameterized\r\n    // route name. Setting the transaction name after the transaction is started could lead\r\n    // to possible race conditions with the router, so this approach was taken.\r\n    if (startTransactionOnPageLoad) {\r\n      prevTransactionName = Router.route !== null ? stripUrlQueryAndFragment(Router.route) : global.location.pathname;\r\n      activeTransaction = startTransactionCb({\r\n        name: prevTransactionName,\r\n        op: 'pageload',\r\n        tags: DEFAULT_TAGS,\r\n      });\r\n    }\r\n\r\n    // Spans that aren't attached to any transaction are lost; so if transactions aren't\r\n    // created (besides potentially the onpageload transaction), no need to wrap the router.\r\n    if (!startTransactionOnLocationChange) return;\r\n\r\n    // `withRouter` uses `useRouter` underneath:\r\n    // https://github.com/vercel/next.js/blob/de42719619ae69fbd88e445100f15701f6e1e100/packages/next/client/with-router.tsx#L21\r\n    // Router events also use the router:\r\n    // https://github.com/vercel/next.js/blob/de42719619ae69fbd88e445100f15701f6e1e100/packages/next/client/router.ts#L92\r\n    // `Router.changeState` handles the router state changes, so it may be enough to only wrap it\r\n    // (instead of wrapping all of the Router's functions).\r\n    const routerPrototype = Object.getPrototypeOf(Router.router);\r\n    fill(routerPrototype, 'changeState', changeStateWrapper);\r\n  });\r\n}\r\n\r\ntype RouterChangeState = (\r\n  method: string,\r\n  url: string,\r\n  as: string,\r\n  options: Record<string, any>,\r\n  ...args: any[]\r\n) => void;\r\ntype WrappedRouterChangeState = RouterChangeState;\r\n\r\n/**\r\n * Wraps Router.changeState()\r\n * https://github.com/vercel/next.js/blob/da97a18dafc7799e63aa7985adc95f213c2bf5f3/packages/next/next-server/lib/router/router.ts#L1204\r\n * Start a navigation transaction every time the router changes state.\r\n */\r\nfunction changeStateWrapper(originalChangeStateWrapper: RouterChangeState): WrappedRouterChangeState {\r\n  const wrapper = function(\r\n    this: any,\r\n    method: string,\r\n    // The parameterized url, ex. posts/[id]/[comment]\r\n    url: string,\r\n    // The actual url, ex. posts/85/my-comment\r\n    as: string,\r\n    options: Record<string, any>,\r\n    // At the moment there are no additional arguments (meaning the rest parameter is empty).\r\n    // This is meant to protect from future additions to Next.js API, especially since this is an\r\n    // internal API.\r\n    ...args: any[]\r\n  ): Promise<boolean> {\r\n    const newTransactionName = stripUrlQueryAndFragment(url);\r\n    // do not start a transaction if it's from the same page\r\n    if (startTransaction !== undefined && prevTransactionName !== newTransactionName) {\r\n      if (activeTransaction) {\r\n        activeTransaction.finish();\r\n      }\r\n      const tags: Record<string, Primitive> = {\r\n        ...DEFAULT_TAGS,\r\n        method,\r\n        ...options,\r\n      };\r\n      if (prevTransactionName) {\r\n        tags.from = prevTransactionName;\r\n      }\r\n      prevTransactionName = newTransactionName;\r\n      activeTransaction = startTransaction({\r\n        name: prevTransactionName,\r\n        op: 'navigation',\r\n        tags,\r\n      });\r\n    }\r\n    return originalChangeStateWrapper.call(this, method, url, as, options, ...args);\r\n  };\r\n  return wrapper;\r\n}\r\n"]}