{"version":3,"file":"instrumentServer.js","sourceRoot":"","sources":["../../src/utils/instrumentServer.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\r\nimport {\r\n  captureException,\r\n  configureScope,\r\n  deepReadDirSync,\r\n  getCurrentHub,\r\n  Handlers,\r\n  startTransaction,\r\n} from '@sentry/node';\r\nimport { extractTraceparentData, getActiveTransaction, hasTracingEnabled } from '@sentry/tracing';\r\nimport { addExceptionMechanism, fill, isString, logger, stripUrlQueryAndFragment } from '@sentry/utils';\r\nimport * as domain from 'domain';\r\nimport * as http from 'http';\r\nimport { default as createNextServer } from 'next';\r\nimport * as querystring from 'querystring';\r\nimport * as url from 'url';\r\n\r\nconst { parseRequest } = Handlers;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\ntype PlainObject<T = any> = { [key: string]: T };\r\n\r\n// class used by `next` as a proxy to the real server; see\r\n// https://github.com/vercel/next.js/blob/4443d6f3d36b107e833376c2720c1e206eee720d/packages/next/server/next.ts#L32\r\ninterface NextServer {\r\n  server: Server;\r\n  createServer: (options: PlainObject) => Server;\r\n}\r\n\r\n// `next`'s main server class; see\r\n// https://github.com/vercel/next.js/blob/4443d6f3d36b107e833376c2720c1e206eee720d/packages/next/next-server/server/next-server.ts#L132\r\ninterface Server {\r\n  dir: string;\r\n  publicDir: string;\r\n}\r\n\r\nexport interface NextRequest extends http.IncomingMessage {\r\n  cookies: Record<string, string>;\r\n  url: string;\r\n  query: { [key: string]: string };\r\n  headers: { [key: string]: string };\r\n  body: string | { [key: string]: unknown };\r\n}\r\ntype NextResponse = http.ServerResponse;\r\n\r\n// the methods we'll wrap\r\ntype HandlerGetter = () => Promise<ReqHandler>;\r\ntype ReqHandler = (req: NextRequest, res: NextResponse, parsedUrl?: url.UrlWithParsedQuery) => Promise<void>;\r\ntype ErrorLogger = (err: Error) => void;\r\ntype ApiPageEnsurer = (path: string) => Promise<void>;\r\ntype PageComponentFinder = (\r\n  pathname: string,\r\n  query: querystring.ParsedUrlQuery,\r\n  params: { [key: string]: unknown } | null,\r\n) => Promise<{ [key: string]: unknown } | null>;\r\n\r\n// these aliases are purely to make the function signatures more easily understandable\r\ntype WrappedHandlerGetter = HandlerGetter;\r\ntype WrappedErrorLogger = ErrorLogger;\r\ntype WrappedReqHandler = ReqHandler;\r\ntype WrappedApiPageEnsurer = ApiPageEnsurer;\r\ntype WrappedPageComponentFinder = PageComponentFinder;\r\n\r\nlet liveServer: Server;\r\nlet sdkSetupComplete = false;\r\n\r\n/**\r\n * Do the monkeypatching and wrapping necessary to catch errors in page routes and record transactions for both page and\r\n * API routes.\r\n */\r\nexport function instrumentServer(): void {\r\n  // The full implementation here involves a lot of indirection and multiple layers of callbacks and wrapping, and is\r\n  // therefore potentially a little hard to follow. Here's the overall idea:\r\n\r\n  // Next.js uses two server classes, `NextServer` and `Server`, with the former proxying calls to the latter, which\r\n  // then does the all real work. The only access we have to either is through Next's default export,\r\n  // `createNextServer()`, which returns a `NextServer` instance.\r\n\r\n  // At server startup:\r\n  //    `next.config.js` imports SDK ->\r\n  //    SDK's `index.ts` runs ->\r\n  //    `instrumentServer()` (the function we're in right now) ->\r\n  //    `createNextServer()` ->\r\n  //    `NextServer` instance ->\r\n  //    `NextServer` prototype ->\r\n  //    Wrap `NextServer.getServerRequestHandler()`, purely to get us to the next step\r\n\r\n  // At time of first request:\r\n  //    Wrapped `getServerRequestHandler` runs for the first time ->\r\n  //    Live `NextServer` instance(via`this`) ->\r\n  //    Live `Server` instance (via `NextServer.server`) ->\r\n  //    `Server` prototype ->\r\n  //    Wrap `Server.logError`, `Server.handleRequest`, `Server.ensureApiPage`, and `Server.findPageComponents` methods,\r\n  //    then fulfill original purpose of function by passing wrapped version of `handleRequest` to caller\r\n\r\n  // Whenever caller of `NextServer.getServerRequestHandler` calls the wrapped `Server.handleRequest`:\r\n  //    Trace request\r\n\r\n  // Whenever something calls the wrapped `Server.logError`:\r\n  //    Capture error\r\n\r\n  // Whenever an API request is handled and the wrapped `Server.ensureApiPage` is called, or whenever a page request is\r\n  // handled and the wrapped `Server.findPageComponents` is called:\r\n  //    Replace URL in transaction name with parameterized version\r\n\r\n  const nextServerPrototype = Object.getPrototypeOf(createNextServer({}));\r\n  fill(nextServerPrototype, 'getServerRequestHandler', makeWrappedHandlerGetter);\r\n}\r\n\r\n/**\r\n * Create a wrapped version of Nextjs's `NextServer.getServerRequestHandler` method, as a way to access the running\r\n * `Server` instance and monkeypatch its prototype.\r\n *\r\n * @param origHandlerGetter Nextjs's `NextServer.getServerRequestHandler` method\r\n * @returns A wrapped version of the same method, to monkeypatch in at server startup\r\n */\r\nfunction makeWrappedHandlerGetter(origHandlerGetter: HandlerGetter): WrappedHandlerGetter {\r\n  // We wrap this purely in order to be able to grab data and do further monkeypatching the first time it runs.\r\n  // Otherwise, it's just a pass-through to the original method.\r\n  const wrappedHandlerGetter = async function(this: NextServer): Promise<ReqHandler> {\r\n    if (!sdkSetupComplete) {\r\n      // stash this in the closure so that `makeWrappedReqHandler` can use it\r\n      liveServer = this.server;\r\n      const serverPrototype = Object.getPrototypeOf(liveServer);\r\n\r\n      // Wrap for error capturing (`logError` gets called by `next` for all server-side errors)\r\n      fill(serverPrototype, 'logError', makeWrappedErrorLogger);\r\n\r\n      // Wrap for request transaction creation (`handleRequest` is called for all incoming requests, and dispatches them\r\n      // to the appropriate handlers)\r\n      fill(serverPrototype, 'handleRequest', makeWrappedReqHandler);\r\n\r\n      // Wrap as a way to grab the parameterized request URL to use as the transaction name for API requests and page\r\n      // requests, respectively. These methods are chosen because they're the first spot in the request-handling process\r\n      // where the parameterized path is provided as an argument, so it's easy to grab.\r\n      fill(serverPrototype, 'ensureApiPage', makeWrappedMethodForGettingParameterizedPath);\r\n      fill(serverPrototype, 'findPageComponents', makeWrappedMethodForGettingParameterizedPath);\r\n\r\n      sdkSetupComplete = true;\r\n    }\r\n\r\n    return origHandlerGetter.call(this);\r\n  };\r\n\r\n  return wrappedHandlerGetter;\r\n}\r\n\r\n/**\r\n * Wrap the error logger used by the server to capture exceptions which arise from functions like `getServerSideProps`.\r\n *\r\n * @param origErrorLogger The original logger from the `Server` class\r\n * @returns A wrapped version of that logger\r\n */\r\nfunction makeWrappedErrorLogger(origErrorLogger: ErrorLogger): WrappedErrorLogger {\r\n  return function(this: Server, err: Error): void {\r\n    // TODO add more context data here\r\n\r\n    // We can use `configureScope` rather than `withScope` here because we're using domains to ensure that each request\r\n    // gets its own scope. (`configureScope` has the advantage of not creating a clone of the current scope before\r\n    // modifying it, which in this case is unnecessary.)\r\n    configureScope(scope => {\r\n      scope.addEventProcessor(event => {\r\n        addExceptionMechanism(event, {\r\n          type: 'instrument',\r\n          handled: true,\r\n          data: {\r\n            function: 'logError',\r\n          },\r\n        });\r\n        return event;\r\n      });\r\n    });\r\n\r\n    captureException(err);\r\n\r\n    return origErrorLogger.call(this, err);\r\n  };\r\n}\r\n\r\n// inspired by next's public file routing; see\r\n// https://github.com/vercel/next.js/blob/4443d6f3d36b107e833376c2720c1e206eee720d/packages/next/next-server/server/next-server.ts#L1166\r\nfunction getPublicDirFiles(): Set<string> {\r\n  try {\r\n    // we need the paths here to match the format of a request url, which means they must:\r\n    // - start with a slash\r\n    // - use forward slashes rather than backslashes\r\n    // - be URL-encoded\r\n    const dirContents = deepReadDirSync(liveServer.publicDir).map(filepath =>\r\n      encodeURI(`/${filepath.replace(/\\\\/g, '/')}`),\r\n    );\r\n    return new Set(dirContents);\r\n  } catch (_) {\r\n    return new Set();\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap the server's request handler to be able to create request transactions.\r\n *\r\n * @param origReqHandler The original request handler from the `Server` class\r\n * @returns A wrapped version of that handler\r\n */\r\nfunction makeWrappedReqHandler(origReqHandler: ReqHandler): WrappedReqHandler {\r\n  const publicDirFiles = getPublicDirFiles();\r\n  // add transaction start and stop to the normal request handling\r\n  const wrappedReqHandler = async function(\r\n    this: Server,\r\n    req: NextRequest,\r\n    res: NextResponse,\r\n    parsedUrl?: url.UrlWithParsedQuery,\r\n  ): Promise<void> {\r\n    // wrap everything in a domain in order to prevent scope bleed between requests\r\n    const local = domain.create();\r\n    local.add(req);\r\n    local.add(res);\r\n    // TODO could this replace wrapping the error logger?\r\n    // local.on('error', Sentry.captureException);\r\n\r\n    local.run(() => {\r\n      const currentScope = getCurrentHub().getScope();\r\n\r\n      if (currentScope) {\r\n        currentScope.addEventProcessor(event => parseRequest(event, req));\r\n\r\n        // We only want to record page and API requests\r\n        if (hasTracingEnabled() && shouldTraceRequest(req.url, publicDirFiles)) {\r\n          // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)\r\n          let traceparentData;\r\n          if (req.headers && isString(req.headers['sentry-trace'])) {\r\n            traceparentData = extractTraceparentData(req.headers['sentry-trace'] as string);\r\n            logger.log(`[Tracing] Continuing trace ${traceparentData?.traceId}.`);\r\n          }\r\n\r\n          // pull off query string, if any\r\n          const reqPath = stripUrlQueryAndFragment(req.url);\r\n\r\n          // requests for pages will only ever be GET requests, so don't bother to include the method in the transaction\r\n          // name; requests to API routes could be GET, POST, PUT, etc, so do include it there\r\n          const namePrefix = req.url.startsWith('/api') ? `${(req.method || 'GET').toUpperCase()} ` : '';\r\n\r\n          const transaction = startTransaction(\r\n            {\r\n              name: `${namePrefix}${reqPath}`,\r\n              op: 'http.server',\r\n              metadata: { requestPath: reqPath },\r\n              ...traceparentData,\r\n            },\r\n            // extra context passed to the `tracesSampler`\r\n            { request: req },\r\n          );\r\n\r\n          currentScope.setSpan(transaction);\r\n\r\n          res.once('finish', () => {\r\n            const transaction = getActiveTransaction();\r\n            if (transaction) {\r\n              transaction.setHttpStatus(res.statusCode);\r\n\r\n              // we'll collect this data in a more targeted way in the event processor we added above,\r\n              // `addRequestDataToEvent`\r\n              delete transaction.metadata.requestPath;\r\n\r\n              // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the\r\n              // transaction closes\r\n              setImmediate(() => {\r\n                transaction.finish();\r\n              });\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      return origReqHandler.call(this, req, res, parsedUrl);\r\n    });\r\n  };\r\n\r\n  return wrappedReqHandler;\r\n}\r\n\r\n/**\r\n * Wrap the given method in order to use the parameterized path passed to it in the transaction name.\r\n *\r\n * @param origMethod Either `ensureApiPage` (called for every API request) or `findPageComponents` (called for every\r\n * page request), both from the `Server` class\r\n * @returns A wrapped version of the given method\r\n */\r\nfunction makeWrappedMethodForGettingParameterizedPath(\r\n  origMethod: ApiPageEnsurer | PageComponentFinder,\r\n): WrappedApiPageEnsurer | WrappedPageComponentFinder {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const wrappedMethod = async function(this: Server, parameterizedPath: string, ...args: any[]): Promise<any> {\r\n    const transaction = getActiveTransaction();\r\n\r\n    // replace specific URL with parameterized version\r\n    if (transaction && transaction.metadata.requestPath) {\r\n      const origPath = transaction.metadata.requestPath;\r\n      transaction.name = transaction.name.replace(origPath, parameterizedPath);\r\n    }\r\n\r\n    return origMethod.call(this, parameterizedPath, ...args);\r\n  };\r\n\r\n  return wrappedMethod;\r\n}\r\n\r\n/**\r\n * Determine if the request should be traced, by filtering out requests for internal next files and static resources.\r\n *\r\n * @param url The URL of the request\r\n * @param publicDirFiles A set containing relative paths to all available static resources (note that this does not\r\n * include static *pages*, but rather images and the like)\r\n * @returns false if the URL is for an internal or static resource\r\n */\r\nfunction shouldTraceRequest(url: string, publicDirFiles: Set<string>): boolean {\r\n  // `static` is a deprecated but still-functional location for static resources\r\n  return !url.startsWith('/_next/') && !url.startsWith('/static/') && !publicDirFiles.has(url);\r\n}\r\n"]}